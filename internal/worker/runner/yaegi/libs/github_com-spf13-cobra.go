// Code generated by 'yaegi extract github.com/spf13/cobra'. DO NOT EDIT.

package libs

import (
	"github.com/spf13/cobra"
	"go/constant"
	"go/token"
	"reflect"
)

func init() {
	Symbols["github.com/spf13/cobra/cobra"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"AddTemplateFunc":                 reflect.ValueOf(cobra.AddTemplateFunc),
		"AddTemplateFuncs":                reflect.ValueOf(cobra.AddTemplateFuncs),
		"AppendActiveHelp":                reflect.ValueOf(cobra.AppendActiveHelp),
		"ArbitraryArgs":                   reflect.ValueOf(cobra.ArbitraryArgs),
		"BashCompCustom":                  reflect.ValueOf(constant.MakeFromLiteral("\"cobra_annotation_bash_completion_custom\"", token.STRING, 0)),
		"BashCompFilenameExt":             reflect.ValueOf(constant.MakeFromLiteral("\"cobra_annotation_bash_completion_filename_extensions\"", token.STRING, 0)),
		"BashCompOneRequiredFlag":         reflect.ValueOf(constant.MakeFromLiteral("\"cobra_annotation_bash_completion_one_required_flag\"", token.STRING, 0)),
		"BashCompSubdirsInDir":            reflect.ValueOf(constant.MakeFromLiteral("\"cobra_annotation_bash_completion_subdirs_in_dir\"", token.STRING, 0)),
		"CheckErr":                        reflect.ValueOf(cobra.CheckErr),
		"CommandDisplayNameAnnotation":    reflect.ValueOf(constant.MakeFromLiteral("\"cobra_annotation_command_display_name\"", token.STRING, 0)),
		"CompDebug":                       reflect.ValueOf(cobra.CompDebug),
		"CompDebugln":                     reflect.ValueOf(cobra.CompDebugln),
		"CompError":                       reflect.ValueOf(cobra.CompError),
		"CompErrorln":                     reflect.ValueOf(cobra.CompErrorln),
		"CompletionWithDesc":              reflect.ValueOf(cobra.CompletionWithDesc),
		"EnableCaseInsensitive":           reflect.ValueOf(&cobra.EnableCaseInsensitive).Elem(),
		"EnableCommandSorting":            reflect.ValueOf(&cobra.EnableCommandSorting).Elem(),
		"EnablePrefixMatching":            reflect.ValueOf(&cobra.EnablePrefixMatching).Elem(),
		"EnableTraverseRunHooks":          reflect.ValueOf(&cobra.EnableTraverseRunHooks).Elem(),
		"Eq":                              reflect.ValueOf(cobra.Eq),
		"ExactArgs":                       reflect.ValueOf(cobra.ExactArgs),
		"ExactValidArgs":                  reflect.ValueOf(cobra.ExactValidArgs),
		"FixedCompletions":                reflect.ValueOf(cobra.FixedCompletions),
		"FlagSetByCobraAnnotation":        reflect.ValueOf(constant.MakeFromLiteral("\"cobra_annotation_flag_set_by_cobra\"", token.STRING, 0)),
		"GetActiveHelpConfig":             reflect.ValueOf(cobra.GetActiveHelpConfig),
		"Gt":                              reflect.ValueOf(cobra.Gt),
		"MarkFlagCustom":                  reflect.ValueOf(cobra.MarkFlagCustom),
		"MarkFlagDirname":                 reflect.ValueOf(cobra.MarkFlagDirname),
		"MarkFlagFilename":                reflect.ValueOf(cobra.MarkFlagFilename),
		"MarkFlagRequired":                reflect.ValueOf(cobra.MarkFlagRequired),
		"MatchAll":                        reflect.ValueOf(cobra.MatchAll),
		"MaximumNArgs":                    reflect.ValueOf(cobra.MaximumNArgs),
		"MinimumNArgs":                    reflect.ValueOf(cobra.MinimumNArgs),
		"MousetrapDisplayDuration":        reflect.ValueOf(&cobra.MousetrapDisplayDuration).Elem(),
		"MousetrapHelpText":               reflect.ValueOf(&cobra.MousetrapHelpText).Elem(),
		"NoArgs":                          reflect.ValueOf(cobra.NoArgs),
		"NoFileCompletions":               reflect.ValueOf(cobra.NoFileCompletions),
		"OnFinalize":                      reflect.ValueOf(cobra.OnFinalize),
		"OnInitialize":                    reflect.ValueOf(cobra.OnInitialize),
		"OnlyValidArgs":                   reflect.ValueOf(cobra.OnlyValidArgs),
		"RangeArgs":                       reflect.ValueOf(cobra.RangeArgs),
		"ShellCompDirectiveDefault":       reflect.ValueOf(cobra.ShellCompDirectiveDefault),
		"ShellCompDirectiveError":         reflect.ValueOf(cobra.ShellCompDirectiveError),
		"ShellCompDirectiveFilterDirs":    reflect.ValueOf(cobra.ShellCompDirectiveFilterDirs),
		"ShellCompDirectiveFilterFileExt": reflect.ValueOf(cobra.ShellCompDirectiveFilterFileExt),
		"ShellCompDirectiveKeepOrder":     reflect.ValueOf(cobra.ShellCompDirectiveKeepOrder),
		"ShellCompDirectiveNoFileComp":    reflect.ValueOf(cobra.ShellCompDirectiveNoFileComp),
		"ShellCompDirectiveNoSpace":       reflect.ValueOf(cobra.ShellCompDirectiveNoSpace),
		"ShellCompNoDescRequestCmd":       reflect.ValueOf(constant.MakeFromLiteral("\"__completeNoDesc\"", token.STRING, 0)),
		"ShellCompRequestCmd":             reflect.ValueOf(constant.MakeFromLiteral("\"__complete\"", token.STRING, 0)),
		"WriteStringAndCheck":             reflect.ValueOf(cobra.WriteStringAndCheck),

		// type definitions
		"Command":            reflect.ValueOf((*cobra.Command)(nil)),
		"Completion":         reflect.ValueOf((*cobra.Completion)(nil)),
		"CompletionFunc":     reflect.ValueOf((*cobra.CompletionFunc)(nil)),
		"CompletionOptions":  reflect.ValueOf((*cobra.CompletionOptions)(nil)),
		"FParseErrWhitelist": reflect.ValueOf((*cobra.FParseErrWhitelist)(nil)),
		"Group":              reflect.ValueOf((*cobra.Group)(nil)),
		"PositionalArgs":     reflect.ValueOf((*cobra.PositionalArgs)(nil)),
		"ShellCompDirective": reflect.ValueOf((*cobra.ShellCompDirective)(nil)),
		"SliceValue":         reflect.ValueOf((*cobra.SliceValue)(nil)),

		// interface wrapper definitions
		"_SliceValue": reflect.ValueOf((*_github_com_spf13_cobra_SliceValue)(nil)),
	}
}

// _github_com_spf13_cobra_SliceValue is an interface wrapper for SliceValue type
type _github_com_spf13_cobra_SliceValue struct {
	IValue    interface{}
	WGetSlice func() []string
}

func (W _github_com_spf13_cobra_SliceValue) GetSlice() []string {
	return W.WGetSlice()
}
